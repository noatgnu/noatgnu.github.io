<!--
	mitm.html is the lite "man in the middle"

	This is only meant to signal the opener's messageChannel to
	the service worker - when that is done this mitm can be closed

	The service worker is capable of intercepting all request and fork their
	own "fake" response - wish we are going to craft
	when the worker then receives a stream then the worker will tell the opener
	to open up a link that will start the download
-->
<html>
<head>
  <script>
    window.onload = function () {
      function onmessage(event) {
        let {data, ports} = event;
        if(!ports || !ports.length) {
          throw new TypeError("Mehhh! You didn't send a messageChannel");
        }
        navigator.serviceWorker.getRegistration('./').then(swReg => {
          return swReg || navigator.serviceWorker.register('/assets/StreamSaver.js/sw.js', {scope: './'})
        }).then(swReg => {
          let swRegTmp = swReg.installing || swReg.waiting;

          if (swReg.active)
            return swReg.active.postMessage(data, [ports[0]]);

          swRegTmp.onstatechange = () => {
            if (swRegTmp.state === 'activated')
              swReg.active.postMessage(data, [ports[0]])
          }
        })
      }
      window.addEventListener('message', onmessage);
      let host = window.location.host;

      // Service worker only works on https, 127.0.0.1 and localhost
      // So we just redirect asap
      if (window.location.host === host && window.location.protocol !== "https:") {
        if (window.location.hostname !== "localhost") {
          window.location.protocol = "https:"
        }
      }


      // The opener can't listen to onload event, so we need to help em out!
      // (telling them that we are ready to accept postMessage's)

      targetWindow = opener;
      if (targetWindow !== null) {
        targetWindow.postMessage('StreamSaver::loadedPopup', '*')
      }
    };

  </script>
</head>
<body>
Delegating worker...
</body>
</html>
